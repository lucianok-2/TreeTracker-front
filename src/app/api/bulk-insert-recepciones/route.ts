import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// Crear cliente con service role key
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { insert_statements, records } = body;

    if (!insert_statements && !records) {
      return NextResponse.json(
        { error: 'Se requieren insert_statements o records' },
        { status: 400 }
      );
    }

    let insertedCount = 0;
    const errors: string[] = [];

    // Obtener el usuario autenticado real desde el request
    const authHeader = request.headers.get('authorization');
    let authenticatedUserId = null;
    
    if (authHeader) {
      try {
        // Crear cliente con el token del usuario autenticado
        const userSupabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
          {
            global: {
              headers: {
                Authorization: authHeader
              }
            }
          }
        );
        
        const { data: { user } } = await userSupabase.auth.getUser();
        if (user) {
          authenticatedUserId = user.id;
          console.log(`‚úÖ Usuario autenticado encontrado: ${authenticatedUserId}`);
        }
      } catch (authError) {
        console.log('‚ö†Ô∏è Error obteniendo usuario autenticado:', authError);
      }
    }
    
    // IMPORTANTE: Usar SIEMPRE el usuario autenticado para mantener separaci√≥n
    const validUserId = authenticatedUserId;
    
    if (!validUserId) {
      console.error('‚ùå No se pudo obtener usuario autenticado');
      return NextResponse.json(
        { error: 'Usuario no autenticado. Por favor inicia sesi√≥n.' },
        { status: 401 }
      );
    }
    
    console.log(`‚úÖ Usando user_id del usuario autenticado: ${validUserId}`);

    if (insert_statements && Array.isArray(insert_statements)) {
      console.log(`üîÑ Procesando ${insert_statements.length} INSERT statements...`);
      
      const parsedRecords = [];
      
      for (const statement of insert_statements) {
        try {
          // Extraer columnas y valores del INSERT statement de forma m√°s flexible
          const columnsMatch = statement.match(/INSERT INTO recepciones \(([^)]+)\)/);
          const valuesMatch = statement.match(/VALUES \(([^)]+)\)/);
          
          if (columnsMatch && valuesMatch) {
            const columns = columnsMatch[1].split(',').map(col => col.trim());
            const values = valuesMatch[1].split(',').map(val => val.trim());
            
            // Crear objeto con los valores parseados
            const record: unknown = {
              user_id: validUserId // Usar siempre el usuario autenticado
            };
            
            // Mapear columnas a valores
            for (let i = 0; i < columns.length; i++) {
              const column = columns[i];
              const value = values[i];
              
              if (column === 'fecha_recepcion') {
                record.fecha_recepcion = value.replace(/'/g, '');
              } else if (column === 'producto_codigo') {
                record.producto_codigo = value.replace(/'/g, '');
              } else if (column === 'proveedor') {
                record.proveedor = value.replace(/'/g, '').replace(/''/g, "'");
              } else if (column === 'num_guia') {
                record.num_guia = value.replace(/'/g, '');
              } else if (column === 'volumen_m3') {
                record.volumen_m3 = parseFloat(value);
              } else if (column === 'certificacion') {
                record.certificacion = value.replace(/'/g, '').replace(/''/g, "'");
              } else if (column === 'rol') {
                record.rol = value.replace(/'/g, '').replace(/''/g, "'");
              } else if (column === 'origen') {
                record.origen = value.replace(/'/g, '').replace(/''/g, "'");
              } else if (column === 'comuna') {
                record.comuna = value.replace(/'/g, '').replace(/''/g, "'");
              }
              // Ignorar user_id del statement, usar el autenticado
            }
            
            parsedRecords.push(record);
            console.log(`‚úÖ Statement parseado correctamente: ${record.num_guia} - ${record.proveedor}`);
          } else {
            console.log(`‚ùå NO SE PUDO PARSEAR STATEMENT: ${statement}`);
            errors.push(`No se pudo parsear statement: ${statement}`);
          }
        } catch (parseError) {
          errors.push(`Error parseando statement: ${parseError}`);
        }
      }

      if (parsedRecords.length > 0) {
        console.log(`üîÑ Insertando ${parsedRecords.length} registros...`);
        console.log('üìã Primer registro de ejemplo:', parsedRecords[0]);

        // DEBUGGING: Mostrar el SQL completo que se va a ejecutar
        console.log('üîç DEBUGGING - SQL COMPLETO:');
        console.log('='.repeat(80));
        
        // Generar el SQL INSERT completo para debugging
        const recordsWithAuthUser = parsedRecords.map(record => ({
          fecha_recepcion: record.fecha_recepcion,
          producto_codigo: record.producto_codigo,
          proveedor: record.proveedor,
          num_guia: record.num_guia,
          volumen_m3: record.volumen_m3,
          certificacion: record.certificacion,
          user_id: validUserId // SIEMPRE usar el usuario autenticado, NUNCA NULL
          // NO incluir 'id' - se auto-genera
          // NO incluir 'created_at' - se auto-genera
          // NO incluir 'updated_at' - se auto-genera
        }));

        // VERIFICACI√ìN CR√çTICA: Asegurar que TODOS los registros tienen user_id v√°lido
        const recordsWithoutUserId = recordsWithAuthUser.filter(r => !r.user_id || r.user_id === null || r.user_id === undefined);
        if (recordsWithoutUserId.length > 0) {
          console.error('‚ùå REGISTROS SIN USER_ID DETECTADOS:', recordsWithoutUserId.length);
          console.error('‚ùå Registros problem√°ticos:', recordsWithoutUserId);
          return NextResponse.json(
            { 
              error: 'Error cr√≠tico: Algunos registros no tienen user_id asignado', 
              details: `${recordsWithoutUserId.length} registros sin user_id`,
              problematic_records: recordsWithoutUserId.length
            },
            { status: 400 }
          );
        }
        
        // VERIFICACI√ìN ADICIONAL: Validar que el user_id es un UUID v√°lido
        const invalidUserIds = recordsWithAuthUser.filter(r => {
          const userId = r.user_id;
          return !userId || typeof userId !== 'string' || userId.length !== 36 || !userId.includes('-');
        });
        
        if (invalidUserIds.length > 0) {
          console.error('‚ùå USER_IDS INV√ÅLIDOS DETECTADOS:', invalidUserIds.length);
          return NextResponse.json(
            { 
              error: 'Error cr√≠tico: Algunos registros tienen user_id inv√°lido', 
              details: `${invalidUserIds.length} registros con user_id inv√°lido`
            },
            { status: 400 }
          );
        }
        
        console.log(`‚úÖ VERIFICACI√ìN COMPLETA: TODOS LOS ${recordsWithAuthUser.length} REGISTROS TIENEN USER_ID V√ÅLIDO: ${validUserId}`);
        console.log(`‚úÖ FORMATO USER_ID VERIFICADO: ${validUserId} (${validUserId.length} caracteres)`);

        // Mostrar el SQL INSERT que se generar√≠a
        const sqlInsertExample = `
INSERT INTO recepciones (fecha_recepcion, producto_codigo, proveedor, num_guia, volumen_m3, certificacion, user_id)
VALUES 
${recordsWithAuthUser.slice(0, 3).map(record => 
  `  ('${record.fecha_recepcion}', '${record.producto_codigo}', '${record.proveedor.replace(/'/g, "''")}', '${record.num_guia}', ${record.volumen_m3}, '${record.certificacion.replace(/'/g, "''")}', '${record.user_id}')`
).join(',\n')}
${recordsWithAuthUser.length > 3 ? `... y ${recordsWithAuthUser.length - 3} registros m√°s` : ''};
        `;
        
        console.log('üìù SQL INSERT que se ejecutar√°:');
        console.log(sqlInsertExample);
        console.log('='.repeat(80));
        
        // Informaci√≥n adicional para debugging
        console.log('üîç INFORMACI√ìN DE DEBUGGING:');
        console.log(`- Total de registros: ${recordsWithAuthUser.length}`);
        console.log(`- Usuario autenticado: ${validUserId}`);
        console.log(`- Primer registro completo:`, JSON.stringify(recordsWithAuthUser[0], null, 2));
        console.log(`- √öltimo registro completo:`, JSON.stringify(recordsWithAuthUser[recordsWithAuthUser.length - 1], null, 2));
        console.log('='.repeat(80));

        // USAR EXACTAMENTE EL MISMO M√âTODO QUE FUNCIONA EN EL DIAGN√ìSTICO
        console.log('üîß USANDO M√âTODO ID√âNTICO AL DIAGN√ìSTICO EXITOSO');
        const userSupabase = supabase; // Usar service role key directo como en el diagn√≥stico

        // DEBUGGING: Verificar el contexto de autenticaci√≥n antes de insertar
        console.log('üîç VERIFICANDO CONTEXTO DE AUTENTICACI√ìN:');
        try {
          const { data: { user: currentUser } } = await userSupabase.auth.getUser();
          console.log('- Usuario actual en el contexto:', currentUser?.id || 'NO AUTENTICADO');
          console.log('- Email del usuario:', currentUser?.email || 'NO DISPONIBLE');
          console.log('- Rol del usuario:', currentUser?.role || 'NO DISPONIBLE');
        } catch (authCheckError) {
          console.log('- Error verificando usuario:', authCheckError);
        }

        // DEBUGGING: Verificar pol√≠ticas RLS activas
        console.log('üîç VERIFICANDO POL√çTICAS RLS:');
        try {
          const { data: policies } = await supabase.rpc('exec_sql', { 
            sql: `SELECT policyname, cmd, qual, with_check FROM pg_policies WHERE tablename = 'recepciones' AND cmd = 'INSERT';`
          });
          console.log('- Pol√≠ticas INSERT activas:', policies);
        } catch (policyError) {
          console.log('- Error obteniendo pol√≠ticas:', policyError);
        }

        try {
          console.log('üöÄ EJECUTANDO INSERCI√ìN MASIVA...');
          const { data, error } = await userSupabase
            .from('recepciones')
            .insert(recordsWithAuthUser)
            .select();

          console.log('üìä RESULTADO DE INSERCI√ìN MASIVA:');
          console.log('- Error:', error);
          console.log('- Data length:', data?.length || 0);
          console.log('- Error code:', error?.code);
          console.log('- Error details:', error?.details);
          console.log('- Error hint:', error?.hint);
          console.log('- Error message completo:', error?.message);

          if (!error && data) {
            insertedCount = data.length;
            console.log(`‚úÖ Inserci√≥n masiva exitosa con usuario autenticado: ${insertedCount} registros`);
          } else {
            throw new Error(`Inserci√≥n masiva fall√≥: ${error?.message} (Code: ${error?.code})`);
          }
        } catch (massInsertError) {
          console.log('‚ö†Ô∏è Inserci√≥n masiva fall√≥, intentando inserci√≥n individual...');
          
          // Fallback: Inserci√≥n individual
          let successCount = 0;
          
          for (const record of recordsWithAuthUser) {
            try {
              console.log(`üìù Insertando registro: ${record.num_guia}`);
              
              const { data: singleData, error: singleError } = await userSupabase
                .from('recepciones')
                .insert([record])
                .select();

              if (!singleError && singleData) {
                successCount++;
                console.log(`‚úÖ Registro ${record.num_guia} insertado exitosamente`);
              } else {
                console.error(`‚ùå Error insertando registro ${record.num_guia}:`, singleError);
                errors.push(`Error insertando registro ${record.num_guia}: ${singleError?.message || 'Error desconocido'}`);
              }
            } catch (singleInsertError) {
              console.error(`‚ùå Excepci√≥n insertando registro ${record.num_guia}:`, singleInsertError);
              errors.push(`Excepci√≥n insertando registro ${record.num_guia}: ${singleInsertError}`);
            }
          }
          
          insertedCount = successCount;
          console.log(`‚úÖ Inserci√≥n individual completada: ${successCount}/${parsedRecords.length} registros`);
        }
      }

    } else if (records && Array.isArray(records)) {
      console.log(`üîÑ Insertando ${records.length} registros directamente...`);
      
      const recordsToInsert = records.map(record => ({
        fecha_recepcion: record.fecha_recepcion,
        producto_codigo: record.producto_codigo,
        proveedor: record.proveedor,
        num_guia: record.num_guia,
        volumen_m3: record.volumen_m3,
        certificacion: record.certificacion,
        user_id: validUserId // Usar el user_id v√°lido
      }));

      console.log('üîß INSERTANDO DIRECTAMENTE CON SUPABASE CLIENT (SIN FUNCI√ìN)');
      console.log('üìã Primer registro a insertar:', recordsToInsert[0]);

      const { data, error } = await supabase
        .from('recepciones')
        .insert(recordsToInsert)
        .select();

      console.log('üìä RESULTADO INSERCI√ìN DIRECTA:');
      console.log('- Error:', error);
      console.log('- Data length:', data?.length || 0);
      console.log('- Error completo:', JSON.stringify(error, null, 2));

      if (error) {
        console.error('‚ùå Error insertando registros:', error);
        return NextResponse.json(
          { error: 'Error insertando registros', details: error.message },
          { status: 500 }
        );
      }

      insertedCount = data?.length || 0;
    }

    console.log(`‚úÖ Inserci√≥n completada: ${insertedCount} registros insertados`);

    return NextResponse.json({
      success: true,
      message: errors.length > 0 
        ? `Se insertaron ${insertedCount} registros con ${errors.length} errores`
        : `Se insertaron ${insertedCount} registros exitosamente`,
      inserted_count: insertedCount,
      errors: errors
    });

  } catch (error) {
    console.error('‚ùå Error en bulk-insert-recepciones:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor', details: error instanceof Error ? error.message : 'Error desconocido' },
      { status: 500 }
    );
  }
}